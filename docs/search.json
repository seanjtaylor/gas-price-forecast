[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Forecasting gas prices demo",
    "section": "",
    "text": "This notebook implements a forecast for US gas prices for the next 13 weeks (roughly one quarter), broken down by region. I am taking this as an opportunity to kick the tires on three new packages I’ve been excited to try out:\nI hope it also just demonstrates what I believe to be an effective way to wrangle data in Python, using Pandas method-chaining, Altair plots, black to automatically cleanup after myself\nI want to be upfront and state that I am an advisor for both Linea and Nixtla. I think both companies are building cool technology for data science and data engineering, and using their packages is a good way for me to contribute as an advisor. If you have feedback about either package, please pass it along to me and I’ll make sure they get it!"
  },
  {
    "objectID": "index.html#matrix-factorizations-are-fun",
    "href": "index.html#matrix-factorizations-are-fun",
    "title": "Forecasting gas prices demo",
    "section": "Matrix factorizations are fun",
    "text": "Matrix factorizations are fun\n\nwide = (\n    df_long.query(f\"week > '{complete_case_date}'\")[[\"week\", \"region\", \"price_change\"]]\n    .set_index(\"week\")\n    .pivot(columns=\"region\", values=\"price_change\")\n)\nmatrix = wide.values\nprint(matrix.shape)\nu, d, v = svd(matrix)\n\n(1009, 28)\n\n\n\n\n\n\nscree_plot = (\n    pd.DataFrame({\"eigenvalue\": d, \"index\": np.arange(d.shape[0])})\n    .pipe(alt.Chart)\n    .encode(x=\"index\", y=\"eigenvalue\")\n    .mark_point()\n)\n\nlineapy.save(scree_plot, \"scree_plot\")\nscree_plot\n\n\n\n\n\n\n\n\n\n\ncomponents = pd.DataFrame(\n    v, columns=[f\"component_{i}\" for i in range(v.shape[0])], index=wide.columns\n).reset_index()\n\ncomponents_plot = (\n    components.pipe(alt.Chart)\n    .encode(x=\"component_0\", y=\"component_1\", text=\"region\")\n    .mark_text()\n    .interactive()\n)\n\nlineapy.save(components_plot, \"components_plot\")\ncomponents_plot"
  },
  {
    "objectID": "index.html#acf-plots-are-price-changes-mean-reverting",
    "href": "index.html#acf-plots-are-price-changes-mean-reverting",
    "title": "Forecasting gas prices demo",
    "section": "ACF plots: are price changes mean-reverting?",
    "text": "ACF plots: are price changes mean-reverting?\nHere we check if changes in gas prices have any autocorrelation. If they do, it indicates there is some momentum: if prices are increasing they are likely to increase next week and we should fill up our tank as soon as possible. If there is no autocorrelation, there’s no real benefit to timing our gas purchases. If the autocorrelation is negative, we may want to wait awhile after prices increase to fill up.\nAnswer: looks like there’s strong positive autocorrelation lasting about 6 weeks. There does appear to be some mean reversion on a longer time-scale (1-2 quarters).\n\nregion = \"U.S.\"\nauto_correlation = (\n    df_long.query(f\"region == '{region}'\")\n    .query(\"price_change == price_change\")[\"price_change\"]\n    .pipe(acf)\n)\nacf_plot = (\n    pd.DataFrame({\"rho\": auto_correlation, \"lag\": np.arange(auto_correlation.shape[0])})\n    .pipe(alt.Chart, title=region)\n    .encode(x=\"lag\", y=\"rho\")\n    .mark_bar()\n)\nlineapy.save(acf_plot, \"acf_plot2\")\nacf_plot"
  },
  {
    "objectID": "index.html#parameter-refactor",
    "href": "index.html#parameter-refactor",
    "title": "Forecasting gas prices demo",
    "section": "Parameter Refactor",
    "text": "Parameter Refactor\nHere is some magic. I can take the last plot I made and directly turn it into a function that makes the plot again – but where I can set new options about the parameters I specified!\nI find this to be a helpful pattern – you can prototype in a procedural way that’s easy to read, and then let LineaPy clean up and turn it into something re-usable later.\n\nforecast_region = lineapy.get_function(\n    [\"gas_price_forecast\"],\n    input_parameters=[\n        \"region\",\n        \"cutoff_date\",\n        \"H\",\n        \"width\",\n        \"height\",\n        \"plot_start_date\",\n    ],\n    reuse_pre_computed_artifacts=[\"weekly_gas_price_data_long\"],\n)\n\n\n\n\nLet’s got back in time and look at a forecast from when prices hit their peak in California.\n\nresult = forecast_region(\n    region=\"California\", cutoff_date=\"2022-06-07\", H=15, width=300, height=250\n)\nresult[\"gas_price_forecast\"]\n\n\n\n\n\n\n\n\n\n\nplots = []\nfor region in all_regions:\n    result = forecast_region(\n        region=region, cutoff_date=cutoff_date, height=200, width=200\n    )\n    plots.append(result[\"gas_price_forecast\"])\n\n\n\n\n\nchart = alt.vconcat()\nfor i, plot in enumerate(plots):\n    if i % 4 == 0:\n        row = alt.hconcat()\n        chart &= row\n    row |= plot\nchart"
  },
  {
    "objectID": "index.html#save-the-final-artifact",
    "href": "index.html#save-the-final-artifact",
    "title": "Forecasting gas prices demo",
    "section": "Save the final artifact",
    "text": "Save the final artifact\nOne thing I can do is just save the final result here somewhere I may reference elsewhere. For instance, in another document I could get this chart and render it (which I do!).\n\nlineapy.save(chart, \"all_forecasts_plot\")\n\nLineaArtifact(name='all_forecasts_plot', _version=0)"
  },
  {
    "objectID": "index.html#generate-a-runnable-pipeline",
    "href": "index.html#generate-a-runnable-pipeline",
    "title": "Forecasting gas prices demo",
    "section": "Generate a runnable pipeline",
    "text": "Generate a runnable pipeline\nHaving kept track of everything we did to make our forecast plots, LineaPy can generate an entire Airflow pipeline that faithfully replicates what I’ve done in this notebook. None of the side-quest analyses or data checking will be included, and the packages I used (and their versions are captured. The one thing I do have to do is include a dependency graph between the different artifacts so that the DAG can reflect this.\nLineaPy is useful locally, but to share my results with others and run pipelines in a different environment, it can also be hosted as in this tutorial.\n\nlineapy.to_pipeline(\n    [\"gas_price_forecast\", \"weekly_gas_price_data\", \"weekly_gas_price_data_long\"],\n    dependencies={\n        \"gas_price_forecast\": {\"weekly_gas_price_data_long\": {\"weekly_gas_price_data\"}}\n    },\n    pipeline_name=\"gas_price_forecast\",\n    output_dir=\"pipeline\",\n    framework=\"AIRFLOW\",\n    input_parameters=[\"region\", \"cutoff_date\"],\n)\n\nGenerated module file: pipeline/gas_price_forecast_module.py                    \nGenerated requirements file: pipeline/gas_price_forecast_requirements.txt       \nGenerated DAG file: pipeline/gas_price_forecast_dag.py                          \nGenerated Docker file: pipeline/gas_price_forecast_Dockerfile                   \n\n\nPosixPath('pipeline')\n\n\n\n\n\n\n!cat pipeline/gas_price_forecast_dag.py\n\nimport pathlib\nimport pickle\n\nimport gas_price_forecast_module\nfrom airflow import DAG\nfrom airflow.operators.python_operator import PythonOperator\nfrom airflow.utils.dates import days_ago\n\n\ndef dag_setup():\n    pickle_folder = pathlib.Path(\"/tmp\").joinpath(\"gas_price_forecast\")\n    if not pickle_folder.exists():\n        pickle_folder.mkdir()\n\n\ndef dag_teardown():\n    pickle_files = pathlib.Path(\"/tmp\").joinpath(\"gas_price_forecast\").glob(\"*.pickle\")\n    for f in pickle_files:\n        f.unlink()\n\n\ndef task_weekly_gas_price_data():\n\n    df = gas_price_forecast_module.get_weekly_gas_price_data()\n\n    pickle.dump(df, open(\"/tmp/gas_price_forecast/variable_df.pickle\", \"wb\"))\n\n\ndef task_weekly_gas_price_data_long():\n\n    df = pickle.load(open(\"/tmp/gas_price_forecast/variable_df.pickle\", \"rb\"))\n\n    df_long = gas_price_forecast_module.get_weekly_gas_price_data_long(df)\n\n    pickle.dump(df_long, open(\"/tmp/gas_price_forecast/variable_df_long.pickle\", \"wb\"))\n\n\ndef task_gas_price_forecast(cutoff_date, region):\n\n    cutoff_date = str(cutoff_date)\n\n    region = str(region)\n\n    df_long = pickle.load(open(\"/tmp/gas_price_forecast/variable_df_long.pickle\", \"rb\"))\n\n    full_plot = gas_price_forecast_module.get_gas_price_forecast(\n        cutoff_date, df_long, region\n    )\n\n    pickle.dump(\n        full_plot, open(\"/tmp/gas_price_forecast/variable_full_plot.pickle\", \"wb\")\n    )\n\n\ndefault_dag_args = {\n    \"owner\": \"airflow\",\n    \"retries\": 2,\n    \"start_date\": days_ago(1),\n    \"params\": {\"region\": \"U.S.\", \"cutoff_date\": \"2022-10-02\"},\n}\n\nwith DAG(\n    dag_id=\"gas_price_forecast_dag\",\n    schedule_interval=\"*/15 * * * *\",\n    max_active_runs=1,\n    catchup=False,\n    default_args=default_dag_args,\n) as dag:\n\n    setup = PythonOperator(\n        task_id=\"dag_setup\",\n        python_callable=dag_setup,\n    )\n\n    teardown = PythonOperator(\n        task_id=\"dag_teardown\",\n        python_callable=dag_teardown,\n    )\n\n    weekly_gas_price_data = PythonOperator(\n        task_id=\"weekly_gas_price_data_task\",\n        python_callable=task_weekly_gas_price_data,\n    )\n\n    weekly_gas_price_data_long = PythonOperator(\n        task_id=\"weekly_gas_price_data_long_task\",\n        python_callable=task_weekly_gas_price_data_long,\n    )\n\n    gas_price_forecast = PythonOperator(\n        task_id=\"gas_price_forecast_task\",\n        python_callable=task_gas_price_forecast,\n        op_kwargs={\n            \"cutoff_date\": \"{{ params.cutoff_date }}\",\n            \"region\": \"{{ params.region }}\",\n        },\n    )\n\n    weekly_gas_price_data >> weekly_gas_price_data_long\n\n    weekly_gas_price_data_long >> gas_price_forecast\n\n    setup >> weekly_gas_price_data\n\n    gas_price_forecast >> teardown\n\n\n\n\n\n\n!cat pipeline/gas_price_forecast_module.py\n\nimport argparse\nimport re\n\nimport altair as alt\nimport numpy as np\nimport pandas as pd\nimport requests\nfrom statsforecast.models import AutoARIMA\n\n\ndef get_weekly_gas_price_data():\n    response = requests.get(\n        \"https://www.eia.gov/petroleum/gasdiesel/xls/pswrgvwall.xls\"\n    )\n    df = pd.read_excel(\n        response.content,\n        sheet_name=\"Data 12\",\n        index_col=0,\n        skiprows=2,\n        parse_dates=[\"Date\"],\n    ).rename(\n        columns=lambda c: re.sub(\n            \"\\(PADD 1[A-C]\\)\",\n            \"\",\n            c.replace(\"Weekly \", \"\").replace(\n                \" All Grades All Formulations Retail Gasoline Prices  (Dollars per Gallon)\",\n                \"\",\n            ),\n        ).strip()\n    )\n    return df\n\n\ndef get_weekly_gas_price_data_long(df):\n    df_long = (\n        df.reset_index()\n        .melt(id_vars=[\"Date\"], var_name=\"region\", value_name=\"price\")\n        .rename(columns={\"Date\": \"week\"})\n        .sort_values([\"region\", \"week\"])\n        .assign(\n            # if we're missing one value, just use the last value\n            # (happens twice)\n            price=lambda x: x[\"price\"].combine_first(\n                x.groupby(\"region\")[\"price\"].shift(1)\n            ),\n            # we'll forecast log(price) and then transform\n            log_price=lambda x: np.log(x[\"price\"]),\n            # percentage price changes are approximately the difference in log(price)\n            price_change=lambda x: (\n                x[\"log_price\"] - x.groupby(\"region\")[\"log_price\"].shift(1)\n            ),\n        )\n        .query(\"price == price\")  # filter out NAs\n    )\n    return df_long\n\n\ndef get_gas_price_forecast(cutoff_date, df_long, region):\n    H = 13\n    CI = 80\n    width = 300\n    height = 250\n    plot_start_date = \"2022-01-01\"\n    plot_title = f\"{region} (as of {cutoff_date})\"\n    region_df = df_long.query(f\"region == '{region}'\")\n    train = region_df.query(f\"week < '{cutoff_date}'\")\n    m_aa = AutoARIMA()\n    m_aa.fit(train[\"log_price\"].values)\n    raw_forecast = m_aa.predict(h=H, level=(CI,))\n    raw_forecast_exp = {key: np.exp(value) for key, value in raw_forecast.items()}\n    forecast = pd.DataFrame(raw_forecast_exp).assign(\n        week=pd.date_range(train[\"week\"].max(), periods=H, freq=\"W\")\n        + pd.Timedelta(\"7 days\")\n    )\n    forecast = pd.concat(\n        [\n            forecast,\n            train.tail(1)\n            .rename(columns={\"price\": \"mean\"})\n            .assign(\n                **{f\"lo-{CI}\": lambda x: x[\"mean\"], f\"hi-{CI}\": lambda x: x[\"mean\"]}\n            ),\n        ]\n    )\n    uncertainty_plot = (\n        forecast.pipe(alt.Chart, height=height, width=width)\n        .encode(\n            x=\"week\",\n            y=alt.Y(f\"lo-{CI}\", title=\"Price\"),\n            y2=alt.Y2(f\"hi-{CI}\", title=\"Price\"),\n        )\n        .mark_area(opacity=0.2)\n    )\n    history_plot = (\n        region_df.query(f\"week >= '{plot_start_date}'\")\n        .pipe(alt.Chart, title=plot_title)\n        .encode(x=alt.X(\"week\", title=\"Week\"), y=alt.Y(\"price\", title=\"Price\"))\n        .mark_line()\n    )\n    forecast_plot = forecast.pipe(alt.Chart).encode(x=\"week\", y=\"mean\").mark_line()\n    cutoff_plot = (\n        train.tail(1).pipe(alt.Chart).encode(x=\"week\").mark_rule(strokeDash=[10, 2])\n    )\n    full_plot = uncertainty_plot + history_plot + forecast_plot + cutoff_plot\n    return full_plot\n\n\ndef run_session_including_weekly_gas_price_data(\n    region=\"U.S.\",\n    cutoff_date=\"2022-10-02\",\n):\n    # Given multiple artifacts, we need to save each right after\n    # its calculation to protect from any irrelevant downstream\n    # mutations (e.g., inside other artifact calculations)\n    import copy\n\n    artifacts = dict()\n    df = get_weekly_gas_price_data()\n    artifacts[\"weekly_gas_price_data\"] = copy.deepcopy(df)\n    df_long = get_weekly_gas_price_data_long(df)\n    artifacts[\"weekly_gas_price_data_long\"] = copy.deepcopy(df_long)\n    full_plot = get_gas_price_forecast(cutoff_date, df_long, region)\n    artifacts[\"gas_price_forecast\"] = copy.deepcopy(full_plot)\n    return artifacts\n\n\ndef run_all_sessions(\n    region=\"U.S.\",\n    cutoff_date=\"2022-10-02\",\n):\n    artifacts = dict()\n    artifacts.update(run_session_including_weekly_gas_price_data(region, cutoff_date))\n    return artifacts\n\n\nif __name__ == \"__main__\":\n    # Edit this section to customize the behavior of artifacts\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--region\", type=str, default=\"U.S.\")\n    parser.add_argument(\"--cutoff_date\", type=str, default=\"2022-10-02\")\n    args = parser.parse_args()\n    artifacts = run_all_sessions(\n        region=args.region,\n        cutoff_date=args.cutoff_date,\n    )\n    print(artifacts)\n\n\n\n\n\n\n!cat pipeline/gas_price_forecast_requirements.txt\n\nstatsforecast==1.0.0\nrequests==2.28.0\nre==2.2.1\naltair==4.2.0\nnumpy==1.21.6\npandas==1.4.2\nscipy==1.7.3\nstatsmodels==0.13.2"
  }
]